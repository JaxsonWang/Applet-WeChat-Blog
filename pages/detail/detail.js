//获取应用实例
const app = getApp()

Page({
  data: {
    desc: { image: '/images/index.png', text: '永远年轻，永远热泪盈眶' },
    test1: "<h3 id=\"\">前言</h3>\n<p>在Nuxt.js打包时候发现<code>vendors</code>文件实在是太大，看了官方文档发现新版又不支持老的Api，所以寻找一上午也没找到很好的方案，目前把一些类库文件抽取出来直接CDN加载就行，但原本以为这是很简单事情，可是中间又遇到不少问题，例如脚本和脚本直接的依赖关系等。</p>\n<!--more-->\n<h3 id=\"html5\">HTML5</h3>\n<p>其实在HTML5也有相关的标签属性可以实现：</p>\n<pre><code class=\"language-javascript\">&lt;script src=&quot;//code.jquery.com/jquery-1.11.0.min.js&quot; async&gt;&lt;/script&gt;\n</code></pre>\n<p>async 属性规定一旦脚本可用，则会异步执行。</p>\n<p>注释：async 属性仅适用于外部脚本（只有在使用 src 属性时）。</p>\n<p>注释：有多种执行外部脚本的方法：</p>\n<ul>\n<li>如果 async=&quot;async&quot;：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</li>\n<li>如果不使用 async 且 defer=&quot;defer&quot;：脚本将在页面完成解析时执行</li>\n<li>如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本</li>\n</ul>\n<h3 id=\"\">编程方式</h3>\n<pre><code class=\"language-javascript\">(function() {\n    var script = document.createElement(&quot;script&quot;);\n    script.type = &quot;text/javascript&quot;;\n    script.async = true;\n    script.src = &quot;//code.jquery.com/jquery-1.11.0.min.js&quot;;\n    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(script);\n})();\n</code></pre>\n<p>这种动态插入脚本的方法基本上主流写法。</p>\n<h3 id=\"\">支持回调函数的编程方式</h3>\n<p>如果需要在插入脚本执行代码执行下一步操作：</p>\n<pre><code class=\"language-javascript\">function loadScript(url, callback) {\n    var script = document.createElement(&quot;script&quot;);\n    script.type = &quot;text/javascript&quot;;\n    script.async = true;\n    if (script.readyState) {\n        script.onreadystatechange = function () {\n            if (script.readyState == &quot;loaded&quot; || script.readyState == &quot;complete&quot;) {\n                script.onreadystatechange = null;\n                if (callback &amp;&amp; typeof callback === &quot;function&quot;) {\n                    callback();\n                }\n            }\n        };\n    } else {\n        script.onload = function () {\n            if (callback &amp;&amp; typeof callback === &quot;function&quot;) {\n                callback();\n            }\n        };\n    }\n    script.src = url;\n    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(script);\n}\n</code></pre>\n<p>理论上这样写法满足大量的需求了，但是在我这里遇到一个问题：</p>\n<p><img src=\"https://i.loli.net/2018/10/26/5bd2b9298dde5.jpg\" alt=\"\"></p>\n<p>如果一层一层回调下去，岂不是难以解读。所以还需要一个更优雅的写法：</p>\n<h3 id=\"es8\">支持回调函数的ES8风格编程方式</h3>\n<pre><code class=\"language-javascript\">async function loadScripts (scripts) {\n    function get (src) {\n        return new Promise(function (resolve, reject) {\n            var el = document.createElement(&quot;script&quot;);\n            el.async = true;\n            el.addEventListener(&quot;load&quot;, function () {\n                resolve(src);\n            }, false);\n            el.addEventListener(&quot;error&quot;, function () {\n                reject(src);\n            }, false);\n            el.src = src;\n            (document.getElementsByTagName(&quot;head&quot;)[0] || document.getElementsByTagName(&quot;body&quot;)[0]).appendChild(el);\n        });\n    }\n \n    const myPromises = scripts.map(async function (script, index) {\n        return await get(script);\n    });\n \n    return await Promise.all(myPromises);\n}\n</code></pre>\n<p>到上面脚本来看，无论哪方面都可以满足了：</p>\n<pre><code class=\"language-javascript\">loadScripts([\n    &quot;https://static.zinoui.com/1.5/compiled/zino.svg.min.js&quot;,\n    &quot;https://static.zinoui.com/libs/jquery/jquery.min.js&quot;\n]).then(function () {\n    return loadScripts([&quot;https://static.zinoui.com/1.5/compiled/zino.chart.min.js&quot;]);\n}).then(function () {\n    $(&quot;#chart&quot;).zinoChart(settings);\n});\n</code></pre>\n"
  }
})
